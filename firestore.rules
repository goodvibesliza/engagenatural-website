rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ---------- Helpers ----------
    function userSnap(uid) {
      return get(/databases/$(database)/documents/users/$(uid));
    }
    function userData(uid) {
      let snap = userSnap(uid);
      return snap != null ? snap.data : null;
    }
    function isSuperAdmin(uid) {
      let u = userData(uid);
      return u != null && u.role == 'super_admin';
    }
    function isApprovedBrandManager(uid) {
      let u = userData(uid);
      return u != null && u.role == 'brand_manager' && u.approved == true;
    }

    // Looser check to accommodate legacy / variant brand-manager role fields
    function isBrandManagerLoose(uid) {
      let u = userData(uid);
      return u != null && (
        // role field may use different casing or variants
        (u.role == 'brand_manager' || u.role == 'brandManager' ||
         u.role == 'manager'       || u.role == 'brand') ||
        // roles map style
        (u.roles != null && (u.roles.brand_manager == true || u.roles.brandManager == true)) ||
        // boolean helpers
        (u.isBrandManager == true)
      ) && (
        // approval flags (any of these counts as approved)
        (u.approved == true) ||
        (u.isApproved == true) ||
        (u.brandApproved == true) ||
        (u.status == 'approved')
      );
    }
    // Null-safe brand ownership helper
    function belongsToBrand(uid, brandId) {
      let u = userData(uid);
      return u != null && ('brandId' in u) && u.brandId == brandId;
    }
    // Verified staff (can post to 'whats-good' only)
    function isVerifiedStaff(uid) {
      let u = userData(uid);
      return u != null && (
        u.role == 'staff' || (u.roles != null && (u.roles.staff == true))
      ) && (
        u.verified == true || u.verificationStatus == 'approved'
      );
    }

    // Pass a PATH to a post doc
    function isPublicPost(path) {
      return exists(path) && get(path).data.visibility == 'public';
    }

    // ---------- users ----------
    // TEMPORARY DEMO SEEDING FIX:
    // Allow full access to user documents to unblock seeding/migration.
    // Tighten these rules once permissions are fully resolved.
    match /users/{uid} {
      // Read: any authenticated user (needed for community byline/avatar enrichment)
      allow read: if request.auth != null;
      // Write: owner-only
      allow write: if request.auth != null && request.auth.uid == uid;
    }
    // Allow per-user subcollections (e.g., drafts) for the owner
    match /users/{uid}/{document=**} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
    }

    // ---------- brands (reference data for brand-owned content) ----------
    // TEMPORARY DEMO SEEDING FIX:
    // Allow any authenticated user to read/write brand documents.
    // NOTE: This is intentionally permissive to unblock demo data seeding.
    //       Tighten these rules after seeding is verified.
    match /brands/{brandId} {
      allow read, write: if true; // TEMPORARY - allows everyone for debugging
    }

    // Allow access to ANY subcollection or document under a brand during debugging
    match /brands/{brandId}/{document=**} {
      allow read, write: if true; // TEMPORARY - allows all subcollections for debugging
    }

    // ---------- test_brands (debugging helper) ----------
    // Used exclusively by local demo seeding scripts to verify permissions.
    // Remove or lock down once seeding issues are resolved.
    match /test_brands/{testId} {
      allow read, write: if true; // TEMPORARY - unrestricted for debugging
    }

    // ---------- retailers (reference data for staff stores) ----------
    // TEMPORARY DEMO SEEDING FIX:
    // Allow any user (even unauthenticated) full access while debugging.
    // Tighten these rules once seeding is confirmed working.
    match /retailers/{retailerId} {
      allow read, write: if true; // TEMPORARY - unrestricted for debugging
    }

    // ---------- trainings (brand publishes; staff self-enroll) ----------
    // TEMPORARY DEMO SEEDING FIX:
    // Allow any authenticated user full access to trainings
    // to unblock demo seeding in emulator/prod. Tighten
    // once seeding is confirmed working.
    match /trainings/{trainingId} {
      allow read, write: if request.auth != null; // TEMPORARY A������,������?o unrestricted
    }

    // ---------- challenges (brand engagement tasks) ----------
    // TEMPORARY DEMO SEEDING FIX:
    // Allow any authenticated user full access while seeding/dev.
    // Tighten these rules once feature and seeding are verified.
    match /challenges/{challengeId} {
      allow read, write: if request.auth != null; // TEMPORARY - permissive for debugging
    }

    // ---------- training_progress (per-user enrollment/progress) ----------
    // TEMPORARY DEMO SEEDING FIX:
    // Allow any authenticated user to read/write training_progress documents.
    // NOTE: This is intentionally permissive to unblock demo data reset.
    //       Tighten these rules after seeding is verified.
    match /training_progress/{progressId} {
      allow read, write: if request.auth != null; // TEMPORARY - permissive for debugging
    }

    // ---------- user_easter_eggs (per-user easter egg finds) ----------
    // TEMPORARY DEMO SEEDING/DEV FIX:
    // Allow any authenticated user to read/write their easter egg progress.
    // Tighten these rules once feature and seeding are verified.
    match /user_easter_eggs/{docId} {
      allow read, write: if request.auth != null; // TEMPORARY - permissive for debugging
    }

    // ---------- community_posts ----------
    match /community_posts/{postId} {
      // Read rules:
      // - Public posts readable by any signed-in user
      // - Additionally, approved/loose brand managers, super admins, or users that belong to the brand
      //   may read posts (even if not public). This unblocks brand dashboard/community views.
      allow read: if request.auth != null && (
        (('visibility' in resource.data) && resource.data.visibility == 'public') ||
        isApprovedBrandManager(request.auth.uid) ||
        isBrandManagerLoose(request.auth.uid) ||
        belongsToBrand(request.auth.uid, resource.data.brandId) ||
        isSuperAdmin(request.auth.uid)
      );

      // Create allowed for approved brand managers, loose brand managers, or super admins
      // Posts can be created in ANY community (not restricted to 'whats-good' only)
      // Additionally, allow VERIFIED staff to create public posts in ANY community (owner-only)
      allow create: if request.auth != null && (
        isApprovedBrandManager(request.auth.uid) ||
        isBrandManagerLoose(request.auth.uid) ||
        isSuperAdmin(request.auth.uid) ||
        (
          isVerifiedStaff(request.auth.uid) &&
          request.resource.data.visibility == 'public' &&
          request.resource.data.userId == request.auth.uid
        ) ||
        // NEW: Allow any signed-in user to post to What's Good (public, owner-only)
        (
          request.resource.data.visibility == 'public' &&
          request.resource.data.userId == request.auth.uid &&
          request.resource.data.communityId == 'whats-good'
        )
      );

      // Updates:
      // - Super admin / brand managers: allowed
      // - Owner: allowed, but may NOT change communityId, visibility, or userId
      //   (prevents escalation by moving post to other communities or toggling visibility)
      allow update: if request.auth != null && (
        isSuperAdmin(request.auth.uid) ||
        isApprovedBrandManager(request.auth.uid) ||
        isBrandManagerLoose(request.auth.uid) ||
        (
          resource.data.userId == request.auth.uid &&
          request.resource.data.communityId == resource.data.communityId &&
          request.resource.data.visibility == resource.data.visibility &&
          request.resource.data.userId == resource.data.userId
        )
      );

      // Deletes: owner or elevated roles.
      allow delete: if request.auth != null && (
        resource.data.userId == request.auth.uid ||
        isApprovedBrandManager(request.auth.uid) ||
        isBrandManagerLoose(request.auth.uid) ||
        isSuperAdmin(request.auth.uid)
      );
    }

    // ---------- verification_requests (user submits for staff review) ----------
    match /verification_requests/{requestId} {
      // Read: owner (supports legacy field names) or staff reviewers (approved/loose brand managers) or super admin
      allow read: if request.auth != null && (
        resource.data.userId == request.auth.uid ||
        resource.data.applicantUid == request.auth.uid ||
        isApprovedBrandManager(request.auth.uid) ||
        isBrandManagerLoose(request.auth.uid) ||
        isSuperAdmin(request.auth.uid)
      );

      // Create: owner-only; force initial status to 'pending' and prevent spoofing reviewer fields
      allow create: if request.auth != null &&
        request.resource.data.userId == request.auth.uid &&
        // If provided, status must be 'pending'
        (!('status' in request.resource.data) || request.resource.data.status == 'pending') &&
        // Disallow reviewer-controlled fields on create
        !('reviewedBy' in request.resource.data) &&
        !('rejectionReason' in request.resource.data) &&
        !('approvedAt' in request.resource.data);

      // Update: only reviewers may update; keep identity fields immutable
      allow update: if request.auth != null && (
        (isApprovedBrandManager(request.auth.uid) || isBrandManagerLoose(request.auth.uid) || isSuperAdmin(request.auth.uid)) &&
        request.resource.data.userId == resource.data.userId &&
        request.resource.data.userEmail == resource.data.userEmail &&
        request.resource.data.submittedAt == resource.data.submittedAt
      );

      // Delete: owner may withdraw only while pending; super admin always may
      allow delete: if request.auth != null && (
        (resource.data.userId == request.auth.uid && resource.data.status == 'pending') ||
        isSuperAdmin(request.auth.uid)
      );
    }

    // Staff/admin messages under a verification request (append-only)
    match /verification_requests/{requestId}/messages/{msgId} {
      // Owner (requester) and reviewers can read. Support legacy field names (userId | applicantUid).
      allow read: if request.auth != null && (
        get(/databases/$(database)/documents/verification_requests/$(requestId)).data.userId == request.auth.uid ||
        get(/databases/$(database)/documents/verification_requests/$(requestId)).data.applicantUid == request.auth.uid ||
        isApprovedBrandManager(request.auth.uid) ||
        isBrandManagerLoose(request.auth.uid) ||
        isSuperAdmin(request.auth.uid)
      );
      // Owner can create replies; reviewers can also add notes if needed (legacy owner fields supported)
      allow create: if request.auth != null && (
        get(/databases/$(database)/documents/verification_requests/$(requestId)).data.userId == request.auth.uid ||
        get(/databases/$(database)/documents/verification_requests/$(requestId)).data.applicantUid == request.auth.uid ||
        isApprovedBrandManager(request.auth.uid) ||
        isBrandManagerLoose(request.auth.uid) ||
        isSuperAdmin(request.auth.uid)
      );
      // Immutable messages
      allow update, delete: if false;
    }

    // ---------- community_comments ----------
    match /community_comments/{commentId} {
      // Readable by any authenticated user (needed for post threads)
      allow read: if request.auth != null;

      // Only the signed-in author may create
      allow create: if request.auth != null &&
        request.resource.data.userId == request.auth.uid;

      // Author or super admin may edit / delete
      allow update, delete: if request.auth != null && (
        resource.data.userId == request.auth.uid ||
        isSuperAdmin(request.auth.uid)
      );
    }

    // ---------- post_likes (one doc per user+post) ----------
    match /post_likes/{likeId} {
      // Counts require read for signed-in users
      allow read: if request.auth != null;

      // Like/unlike allowed only for the owner
      allow create: if request.auth != null &&
        request.resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null &&
        resource.data.userId == request.auth.uid;

      // Likes are immutable otherwise
      allow update: if false;
    }

    // ---------- sample_programs (brand-funded product campaigns) ----------
    // TEMPORARY DEMO SEEDING FIX:
    // Allow any authenticated user full access to sample_programs for seeding.
    // Tighten these rules once seeding is confirmed working.
    match /sample_programs/{programId} {
      allow read, write: if request.auth != null; // TEMPORARY - permissive for debugging
    }

    // ---------- sample_requests (staff request; brand fulfills) ----------
    // TEMPORARY DEMO SEEDING FIX:
    // Allow any authenticated user full access to sample_requests for seeding.
    // Tighten these rules once seeding is confirmed working.
    match /sample_requests/{reqId} {
      allow read, write: if request.auth != null; // TEMPORARY - permissive for debugging
    }

    // ---------- announcements (brand -> staff) ----------
    // TEMPORARY DEMO SEEDING FIX:
    // Allow any authenticated user full access to announcements for seeding.
    // Tighten these rules once seeding is confirmed working.
    match /announcements/{annId} {
      allow read, write: if request.auth != null; // TEMPORARY - permissive for debugging
    }

    // ---------- lessons (brand educational content) ----------
    // TEMPORARY DEMO SEEDING FIX:
    // Allow any authenticated user full access to lessons for seeding.
    // Tighten these rules once seeding is confirmed working.
    match /lessons/{lessonId} {
      allow read, write: if request.auth != null; // TEMPORARY - permissive for debugging
    }

    // ---------- templates ----------
    match /templates/{templateId} {
      // Any signed-in user can read templates
      allow read: if request.auth != null;

      // Only approved brand managers (any brand) or super_admin may create
      allow create: if request.auth != null &&
        (isApprovedBrandManager(request.auth.uid) || isSuperAdmin(request.auth.uid));

      // Same roles can update / delete
      allow update, delete: if request.auth != null &&
        (isApprovedBrandManager(request.auth.uid) || isSuperAdmin(request.auth.uid));
    }

    // ---------- test_permissions (demo seeding helper) ----------
    match /test_permissions/{docId} {
      // Restrict to super_admin so production data stays safe
      allow read, write: if request.auth != null && isSuperAdmin(request.auth.uid);
    }

    // ---------- communities ----------
    match /communities/{communityId} {
      // Read if:
      //   • community is public & active, OR
      //   • requester is an approved brand manager, OR
      //   • requester is a super admin
      allow read: if request.auth != null && (
        (resource.data.isPublic == true && (!('isActive' in resource.data) || resource.data.isActive == true)) ||
        isApprovedBrandManager(request.auth.uid) ||
        belongsToBrand(request.auth.uid, resource.data.brandId) ||
        isBrandManagerLoose(request.auth.uid) ||
        isSuperAdmin(request.auth.uid)
      );

      // Create allowed for approved brand managers or super admins
      allow create: if request.auth != null && (
        isApprovedBrandManager(request.auth.uid) ||
        isBrandManagerLoose(request.auth.uid) ||
        isSuperAdmin(request.auth.uid)
      );

      // Update & delete follow the same permission set
      allow update, delete: if request.auth != null && (
        isApprovedBrandManager(request.auth.uid) ||
        isBrandManagerLoose(request.auth.uid) ||
        isSuperAdmin(request.auth.uid)
      );
    }

    // ---------- brands/{brandId}/communities (brand-scoped) ----------
    match /brands/{brandId}/communities/{communityId} {
      // Read if:
      //   • community is public & active, OR
      //   • requester is an approved/loose brand manager, OR
      //   • requester is a super admin
      allow read: if request.auth != null && (
        (resource.data.isPublic == true && (!('isActive' in resource.data) || resource.data.isActive == true)) ||
        isApprovedBrandManager(request.auth.uid) ||
        belongsToBrand(request.auth.uid, resource.data.brandId) ||
        isBrandManagerLoose(request.auth.uid) ||
        isSuperAdmin(request.auth.uid)
      );

      // Create allowed for approved/loose brand managers or super admins
      allow create: if request.auth != null && (
        isApprovedBrandManager(request.auth.uid) ||
        isBrandManagerLoose(request.auth.uid) ||
        isSuperAdmin(request.auth.uid)
      );

      // Update & delete follow the same permission set
      allow update, delete: if request.auth != null && (
        isApprovedBrandManager(request.auth.uid) ||
        isBrandManagerLoose(request.auth.uid) ||
        isSuperAdmin(request.auth.uid)
      );
    }

    // ---------- any/**/communities (collection-group queries) ----------
    // Allows listing or querying `collectionGroup('communities')` from any depth.
    // Same permission logic as the top-level & brand-scoped rules.
    match /{path=**}/communities/{communityId} {
      allow read: if request.auth != null && (
        (resource.data.isPublic == true && (!('isActive' in resource.data) || resource.data.isActive == true)) ||
        isApprovedBrandManager(request.auth.uid) ||
        belongsToBrand(request.auth.uid, resource.data.brandId) ||
        isBrandManagerLoose(request.auth.uid) ||
        isSuperAdmin(request.auth.uid)
      );

      allow create: if request.auth != null && (
        isApprovedBrandManager(request.auth.uid) ||
        isBrandManagerLoose(request.auth.uid) ||
        isSuperAdmin(request.auth.uid)
      );

      allow update, delete: if request.auth != null && (
        isApprovedBrandManager(request.auth.uid) ||
        isBrandManagerLoose(request.auth.uid) ||
        isSuperAdmin(request.auth.uid)
      );
    }

    // ---------- community_likes ----------
    match /community_likes/{likeId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
      allow update: if false; // likes are immutable
    }

    // ---------- brand_follows (user follows brands) ----------
    match /brand_follows/{docId} {
      // Create limited to the owner
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      // Temporarily allow read to any authenticated user so brand managers can list followers
      allow read: if request.auth != null;
      // Owner-only updates/deletes; guard against missing userId field
      allow update, delete: if request.auth != null && ('userId' in resource.data) && resource.data.userId == request.auth.uid;
    }

    // ---------- roi_scenarios (brand ROI calculator saved scenarios) ----------
    match /roi_scenarios/{scenarioId} {
      // Brand managers (approved/loose), super admins, or users that belong to the brand can read
      allow read: if request.auth != null && (
        isApprovedBrandManager(request.auth.uid) ||
        isBrandManagerLoose(request.auth.uid) ||
        belongsToBrand(request.auth.uid, resource.data.brandId) ||
        isSuperAdmin(request.auth.uid)
      );

      // Create: super admins can always create; managers must match their own brandId (null-safe)
      allow create: if request.auth != null && (
        isSuperAdmin(request.auth.uid) || (
          (isApprovedBrandManager(request.auth.uid) || isBrandManagerLoose(request.auth.uid)) &&
          belongsToBrand(request.auth.uid, request.resource.data.brandId)
        )
      );

      // Update/Delete: super admins can always modify; managers must match their own brandId (null-safe)
      allow update, delete: if request.auth != null && (
        isSuperAdmin(request.auth.uid) || (
          (isApprovedBrandManager(request.auth.uid) || isBrandManagerLoose(request.auth.uid)) &&
          belongsToBrand(request.auth.uid, resource.data.brandId)
        )
      );
    }

    // ---------- notifications (per-user) ----------
    // System notifications created by admins, readable by the owner only
    match /notifications/{uid}/system/{docId} {
      // Owner can read their own notifications
      allow read: if request.auth != null && request.auth.uid == uid;
      // Owner can update their own notifications (e.g., mark as read)
      allow update, delete: if request.auth != null && request.auth.uid == uid;
      // Creation allowed for owner or super_admin (admin flow writes to applicant's inbox)
      allow create: if request.auth != null && (request.auth.uid == uid || isSuperAdmin(request.auth.uid));
    }

    // Community unread counts per user (client-maintained counters)
    match /notifications/{uid}/community/{communityId} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
    }
  }
}
